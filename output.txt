The following text is a Git repository with code. The structure of the text are sections that begin with ----, followed by a single line containing the file path and file name, followed by a variable amount of lines containing the file contents. The text representing the Git repository ends when the symbols --END-- are encounted. Any further text beyond --END-- are meant to be interpreted as instructions using the aforementioned Git repository as context.
----
simulation.tsx
// src/components/simulation/simulation.tsx
import React, { useMemo } from "react";
import { Chart } from "@/components/simulation/chart";
import { Sliders } from "@/components/simulation/sliders";
import { Button } from "@/components/ui/button";
import { useConverter } from "@/components/simulation/contexts/converter-context";
import { useProteinParameters } from "@/components/simulation/hooks/use-protein-parameters";
import { useWebSocketSimulation } from "@/components/simulation/hooks/use-websocket-simulation";
import { useSimulator } from "@/components/simulation/contexts/simulator-context";

export const Simulation: React.FC = () => {
  const { convertResult } = useConverter();
  const { simulationData } = useSimulator();

  const { proteinParameter, handleProteinParamChange } = useProteinParameters(convertResult);

  useWebSocketSimulation(proteinParameter);

  const proteinNames = useMemo(() => {
    return convertResult ? Object.values(convertResult.proteins) : [];
  }, [convertResult]);

  const chartData = useMemo(() => {
    if (simulationData && convertResult) {
      return simulationData.map((row) => {
        const dataPoint: { [key: string]: number } = { time: row[0] };
        proteinNames.forEach((name, index) => {
          dataPoint[name] = row[index + 1];
        });
        return dataPoint;
      });
    } else {
      return [];
    }
  }, [simulationData, convertResult, proteinNames]);

  return (
    <div className="flex flex-col w-full h-full">
      {convertResult && chartData.length > 0 ? (
        <div className="flex flex-col flex-grow">
          <div className="h-[45vh]">
            <Chart chartData={chartData} proteinNames={proteinNames} />
          </div>
          <div className="h-[40vh]">
            <Sliders
              proteinParameter={proteinParameter}
              handleProteinParamChange={handleProteinParamChange}
              proteinNames={proteinNames}
            />
          </div>
          <div className="h-[10vh] flex items-center justify-center">
            <Button className="mt-4">Run</Button>
          </div>
        </div>
      ) : (
        <div className="flex flex-col justify-center items-center flex-grow text-center">
          <span>No results found.</span>
        </div>
      )}
    </div>
  );
};

----
chart.tsx
// src/components/simulation/chart.tsx
import React from "react";
import { Card, CardHeader, CardTitle, CardContent } from "@/components/ui/card";
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer, Label } from "recharts";

interface LineChartComponentProps {
  chartData: any[];
  proteinNames: string[];
}

interface CustomTooltipProps {
  active?: boolean;
  payload?: { color: string; name: string; value: number }[];
}

const CustomTooltip: React.FC<CustomTooltipProps> = ({ active, payload }) => {
  if (active && payload && payload.length) {
    return (
      <div className="bg-white border border-gray-300 p-2 rounded shadow-lg">
        {payload.map((entry, index) => (
          <p key={index} style={{ color: entry.color }} className="text-sm">
            {entry.name}: {entry.value.toPrecision(3)}
          </p>
        ))}
      </div>
    );
  }

  return null;
};

export const Chart: React.FC<LineChartComponentProps> = ({ chartData, proteinNames }) => {
  return (
    <Card className="border-0 h-full">
      <CardHeader className="items-center p-2 h-[5vh]">
        <CardTitle className="text-lg">Simulation Result</CardTitle>
      </CardHeader>
      <CardContent className="flex h-[40vh]">
        <ResponsiveContainer width="100%" height="100%">
          <LineChart data={chartData} className="h-full">
            <CartesianGrid strokeDasharray="3 3" />
            <XAxis dataKey="time" tick={false}>
              <Label value="Time" position="insideBottomRight" />
            </XAxis>
            <YAxis>
              <Label value="Protein Levels" angle={-90} offset={5} position="insideLeft" />
            </YAxis>
            <Tooltip content={<CustomTooltip />} />
            <Legend />
            {proteinNames.map((name, index) => (
              <Line
                key={name}
                type="monotone"
                dataKey={name}
                stroke={`hsl(${(index * 60) % 360}, 70%, 50%)`}
                strokeWidth={2}
                dot={false}
              />
            ))}
          </LineChart>
        </ResponsiveContainer>
      </CardContent>
    </Card>
  );
};

----
sliders.tsx
// src/components/simulation/sliders.tsx
import React from "react";
import { Slider } from "@/components/ui/slider";
import { Label } from "@/components/ui/label";
import { Card, CardContent } from "@/components/ui/card";
import { ScrollArea, ScrollBar } from "@/components/ui/scroll-area";

interface SlidersComponentProps {
  proteinParameter: number[];
  handleProteinParamChange: (index: number) => (value: number[]) => void;
  proteinNames: string[];
}

export const Sliders: React.FC<SlidersComponentProps> = ({
  proteinParameter,
  handleProteinParamChange,
  proteinNames,
}) => {
  return (
    <Card className="h-full border-0">
      <CardContent className="h-full">
        <ScrollArea className="h-full">
          {proteinParameter.map((param, index) => (
            <div
              key={proteinNames[index]}
              className="flex items-center mb-4 py-4 pr-4"
            >
              <Label htmlFor={`slider-${index}`} className="w-28 pr-2">
                {proteinNames[index]}
              </Label>
              <Slider
                id={`slider-${index}`}
                min={1}
                max={1000}
                step={1}
                value={[param]}
                onValueChange={handleProteinParamChange(index)}
                className="w-full"
              />
              <span className="w-20 text-right">{param}</span>
            </div>
          ))}
          <ScrollBar />
        </ScrollArea>
      </CardContent>
    </Card>
  );
};

----
contexts/simulator-context.tsx
// contexts/simulator-context.tsx
import React, { createContext, useContext, useState } from 'react';

interface SimulatorContextProps {
  simulationData: number[][] | null;
  setSimulationData: React.Dispatch<React.SetStateAction<number[][] | null>>;
}

const SimulatorContext = createContext<SimulatorContextProps | undefined>(undefined);

export const SimulatorProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [simulationData, setSimulationData] = useState<number[][] | null>(null);

  return (
    <SimulatorContext.Provider value={{ simulationData, setSimulationData }}>
      {children}
    </SimulatorContext.Provider>
  );
};

export const useSimulator = (): SimulatorContextProps => {
  const context = useContext(SimulatorContext);
  if (!context) {
    throw new Error('useSimulator must be used within a SimulatorProvider');
  }
  return context;
};

----
contexts/converter-context.tsx
// contexts/converter-context.tsx
import React, { createContext, useContext, useState } from 'react';
import { ConverterResponseData } from '@/components/simulation/hooks/use-simulator-api';

interface ConverterContextProps {
  convertResult: ConverterResponseData | null;
  setConvertResult: React.Dispatch<React.SetStateAction<ConverterResponseData | null>>;
}

const ConverterContext = createContext<ConverterContextProps | undefined>(undefined);

export const ConverterProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [convertResult, setConvertResult] = useState<ConverterResponseData | null>(null);

  return (
    <ConverterContext.Provider value={{ convertResult, setConvertResult }}>
      {children}
    </ConverterContext.Provider>
  );
};

export const useConverter = (): ConverterContextProps => {
  const context = useContext(ConverterContext);
  if (!context) {
    throw new Error('useConverter must be used within a ConverterProvider');
  }
  return context;
};

----
hooks/use-simulator-api.ts
// hooks/use-simulator-api.ts
import { invoke } from "@tauri-apps/api/tauri";

export interface ConverterRequestData {
  flow_json: string;
}

export interface ConverterResponseData {
  num_protein: number;
  proteins: { [key: string]: string };
  function_str: string;
}

export const callCircuitConverterAPI = async (data: ConverterRequestData) => {
  return await invoke<ConverterResponseData>("call_circuit_converter_api", {
    flowJson: data.flow_json,
  });
};

----
hooks/use-protein-parameters.ts
// hooks/use-protein-parameters.ts
import { useState, useEffect } from 'react';
import { ConverterResponseData } from '@/components/simulation/hooks/use-simulator-api';

export const useProteinParameters = (convertResult: ConverterResponseData | null) => {
  const [proteinParameter, setProteinParameter] = useState<number[]>([]);

  useEffect(() => {
    if (convertResult !== null) {
      const initParameter = Array(convertResult.num_protein).fill(1);
      setProteinParameter(initParameter);
    }
  }, [convertResult]);

  const handleProteinParamChange = (index: number) => (value: number[]) => {
    setProteinParameter((prevParams) => {
      const newProteinParams = [...prevParams];
      newProteinParams[index] = value[0];
      return newProteinParams;
    });
  };

  return {
    proteinParameter,
    handleProteinParamChange,
  };
};

----
hooks/use-websocket-simulation.ts
// hooks/use-websocket-simulation.ts
import { useEffect, useRef } from 'react';
import { useConverter } from '@/components/simulation/contexts/converter-context';
import { useSimulator } from '@/components/simulation/contexts/simulator-context';

export const useWebSocketSimulation = (proteinParameter: number[]) => {
  const { convertResult } = useConverter();
  const { setSimulationData } = useSimulator();
  const wsRef = useRef<WebSocket | null>(null);

  useEffect(() => {
    if (convertResult !== null && proteinParameter.length > 0) {
      if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {
        sendParameters(wsRef.current, proteinParameter);
        return;
      }

      const ws = new WebSocket("ws://127.0.0.1:8000/ws/simulation");

      ws.onopen = () => {
        ws.send(JSON.stringify(convertResult));
        sendParameters(ws, proteinParameter);
      };

      ws.onmessage = (event) => {
        try {
          const receivedData = JSON.parse(event.data) as number[][];
          setSimulationData(receivedData);
        } catch (error) {
          console.log("Received non-JSON data:", event.data);
        }
      };

      ws.onerror = (error) => {
        console.error("WebSocket error:", error);
      };

      ws.onclose = () => {
        wsRef.current = null;
      };

      wsRef.current = ws;

      return () => {
        if (wsRef.current) {
          wsRef.current.close();
          wsRef.current = null;
        }
      };
    }
  }, [convertResult, proteinParameter, setSimulationData]);

  useEffect(() => {
    const ws = wsRef.current;
    if (ws && ws.readyState === WebSocket.OPEN) {
      sendParameters(ws, proteinParameter);
    }
  }, [proteinParameter]);

  const sendParameters = (ws: WebSocket, parameters: number[]) => {
    const params = JSON.stringify({ params: parameters });
    ws.send(params);
  };
};

--END--